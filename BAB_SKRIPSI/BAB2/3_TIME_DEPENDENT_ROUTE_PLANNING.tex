Semua teknik akselerasi pencarian rute terpendek, seperti ALT, Arc Flags, Customizable Route Planning, Contraction Hierarchies yang dijelaskan pada subbab 2.1 beroperasi pada jaringan jalan tidak bergantung pada waktu, dimana bobot dari setiap sisi statis dan tidak bergantung pada waktu. Pada jaringan jalan perkotaan, waktu tempuh setiap jalan sering berubah karena kemacetan. Oleh karena itu, teknik akselerasi untuk jaringan jalan tidak bergantung pada waktu seringkali tidak menghasilkan rute yang optimal. Oleh karena itu beberapa penelitian mengusulkan beberapa teknik akselerasi yang dapat diterapkan pada jaringan jalan bergantung pada waktu. Pada jaringan jalan bergantung pada waktu, bobot dari setiap sisi $e$ dari graf adalah sebuah fungsi periodik $len(e,x): \Pi \rightarrow \mathbb{R}^{+}, \Pi=[0,p],p\in \mathbb{N}$. Algoritma klasik dijkstra dapat diterapkan pada jaringan jalan bergantung pada waktu dengan sedikit modifikasi (\cite{Cooke1966}). Ketika melakukan relaksasi sisi $(u,v)$ bobot dari sisi dievaluasi dengan nilai dari bobot untuk waktu $\tau + d(s,u,\tau)$, dimana $\tau$ adalah waktu keberangkatan. \textit{Upper bound} dan \textit{lower bound} dari bobot dari suatu sisi didefinisikan dengan $\underline{len(u)}=\min_{x\in \Pi }len(u,x) $ dan $\overline{len(u)}=\max_{x\in \Pi }len(u,x) $. $d_{*}(s,t)$ adalah jarak terpendek tentatif antara simpul $s$ dan $t$ untuk semua kemungkinan waktu keberangkatan $\in\Pi$. $d(s,t,\tau)$ adalah jarak terpendek tentatif antara simpul $s$ dan $t$ jika berangkat dari simpul $s$ pada waktu $\tau\in \Pi$.

Penelitan oleh \cite{Nannicini2008} memperkenalkan algoritma ALT yang beroperasi pada jaringan jalan bergantung pada waktu. Pemilihan \textit{landmark} dan komputasi jarak antara landmarks dan semua simpul beroperasi pada graf batas bawah $\underline{G}$, dimana $\underline{G}=(V,\underline{E})=(V,\{e \mid e\in E \text{ dan } len(e, x)=\min_{x\in \Pi } len(e, x)  \})$. Fase 1 dari pencarian dua arah ALT, terdiri dari \textit{forward search} yang beroperasi pada graf bergantung pada waktu, dan dan \textit{backward search} berjalan pada graf batas bawah $\underline{G}$. Semua simpul yang diselesaikan oleh \textit{backward search} ditambahkan ke himpunan M, pencarian berhenti ketika kedua pencarian bertemu pada simpul yang sama. Fase 2 dari kueri dua arah ALT, misalkan simpul $v\in V$ adalah simpul yang di \textit{settle} oleh kedua \textit{search}, pencarian pada fase pertama masih dapat dilanjutkan selama nilai minimum dari \textit{key} dari \textit{priority queue} \textit{backward search} $\beta \leq \mu$, dimana $\mu= \gamma_{\tau}(p_v) \text{ dimana }\gamma_{\tau}(p_v) \text{ adalah total bobot dari rute } p_v \text{ dari } s \text{ ke }t \text{ melewati }v$. Pada fase ketiga, hanya \textit{forward search} yang dijalankan dan hanya simpul $v\in M$ yang boleh di kunjungi. \textit{Forward search} fase ketiga berhenti ketika simpul $t$ dihapus dari \textit{priority queue}. 

Teknik akselerasi Arc-Flags yang dipekernalkan oleh \cite{Kohler2005} juga dapat diadaptasi untuk jaringan jalan bergantung pada waktu. Arc-flag $AF_C(e)$ ditetapkan nilainya sebagai \textit{true} jika $e$ terletak pada jalur rute terpendek menuju suatu simpul pada sel $C$ setidaknya satu kali selama periode waktu $\Pi$. Untuk komputasi arc-flags pada graf bergantung pada waktu, buat graf profil di graf terbalik $\overleftarrow{G}$ untuk semua simpul batas $b\in B_C$ untuk semua sel $C$. Lalu, tetapkan nilai $AF_C(u,v)=true$ jika sisi $(u,v)$ merupakan $PG-edge$ dan terletak pada jalur terpendek pada setidaknya satu graf profil yang dibangun dari semua simpul batas $b\in B_C$. Kueri dilakukan dengan \textit{time-dependent} dijkstra dengan hanya melakukan relaksasi sisi $(u,v)$ yang memiliki nilai $AF_C(u,v)=true$ jika $C$ adalah sel dari simpul target. Untuk membangun profil graf $PG$, jalankan algoritma dijkstra dari simpul asal dan tetapkan label jarak $d_*(s,s)=\text{jarak antara s dan s untuk semua kemungkinan waktu keberangkatan} \in \Pi=0$ dan $d_*(s,u)=\infty$. Lalu, disetiap iterasi, simpul $u$ dengan nilai \textit{key} $\underline{d_*^{(s,u)}}$ paling kecil dihapus dari \textit{priority queue}. Lakukan relaksasi sisi $(u,v)$ jika dan hanya jika $l(v)=d_*(s,u)\oplus len(e)<d_*(s,v) , e=(u,v)$, dimana $f\oplus g=g\circ f$. Pencarian dihentikan ketika $\underline{d}(s,u)\geq \overline{d}(s,t)$. Sisi $(u,v)$ disebut sebagai $PG-edge$ jika $d_*(s,u)\oplus len(e)>d_*(s,v)$ tidak berlaku. Dengan kata lain, sisi $(u,v)$ adalah $PG-edge$ jika $(u,v)$ merupakan bagian dari rute terpendek dari $s$ ke $v$ untuk setidaknya satu waktu keberangkatan.



Metode Time-Dependent Contraction Hierarchies (TCH) yang diperkenalkan oleh \cite{Veit2013} merupakan perluasan dari Contraction Hierarchies (CH) pada graf dengan bobot bergantung waktu. Pada fase praproses, simpul-simpul diurutkan berdasarkan fungsi biaya yang dihitung melalui kontraksi simulasi dengan mempertimbangkan kedalaman hierarki, rasio jumlah sisi jalan pintas dengan sisi yang dihapus, jumlah sisi asli yang terwakili oleh sisi jalan pintas, dan kompleksitas dari fungsi waktu tempuh sisi. Simpul kemudian dikontraksi menurut urutan fungsi biaya. Untuk setiap pasangan $u\rightarrow_f x \rightarrow_f v$ akan dihitung waktu kedatangan ke $v$ dari $u$ melalui simpul $x$, $h_{u\rightarrow x \rightarrow v}=g\oplus f + \tau_0$. Jika rute $u\rightarrow_f x \rightarrow_f v$ merupakan rute \textit{earliest arrival} untuk setidaknya satu waktu keberangkatan $\tau_0$, maka ditambahkan sisi jalan pintas $(u,v)$. Kueri dapat dijawab dengan cara pencarian dua arah, dimana \textit{forward search} menggunakan prosedur \textit{time-dependent dijkstra} dan \textit{backward search} menggunakan \textit{profile interval search}.

