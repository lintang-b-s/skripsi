Untuk mencari rute alternatif, \cite{Abraham2010} memperkenalkan metode heuristik \textit{admissible paths} Adimissble Paths untuk mencari rute alternatif pada jaringan jalan. Secara intuitif, rute alternatif berbeda secara signifikan dari rute tercepat $Opt$, tetapi rute tersebut masuk akal dan tidak lebih jauh daripada rute $Opt$ (\cite{Abraham2010}). Misalkan $P$ adalah suatu rute pada graf,  $l(P)$ adalah penjumlahan bobot dari sisi-sisi yang membangun rute $P$. $dist(s,t)$ adalah jarak dari rute terpendek dari simpul $s$ ke simpul $t$. Diberikan semua kemungkinan rute $P$ dari simpul $s$ ke simpul $t$, rute $P$ disebut sebagai \textit{admissible alternative} jika memenuhi sifat-sifat berikut:
\begin{enumerate}
    \item \textit{Limited sharing}. Penjumlahan \textit{travel time} dari sisi-sisi yang muncul pada kedua rute \textit{Opt} dan rute \textit{P}  kurang dari $\gamma \cdot dist(s,t), 0 \leq \gamma \leq 1$.
    \item \textit{T-Local optimality}. Setiap subrute dari $u$ ke $v$ dari $P$ yang  memiliki \textit{travel time} lebih kecil dari $\alpha \cdot dist(s,t), 0<\alpha<1$, haruslah rute terpendek dari subrute.
    \item \textit{Bounded stretch}. Setiap pasang simpul $u,v\in P$, berlaku $l(P_{uv})< (1+\epsilon)\cdot dist(u,v), \epsilon \geq 1$. 
\end{enumerate}


Algoritma pencarian rute alternatif dimulai dari menjalankan $TAMLBD$~\ref{alg:crp-tamlbd} untuk mendapatkan kandidat \textit{via nodes} $Via=\{v, v\in V \text{ dan via node } v \text{ dikunjungi pada forward search dan backward search dari\}}$. Untuk semua kemungkinan rute $P$ dari $s$ ke $t$, $P_v$ memiliki nilai \textit{stretch} yang sangat kecil, atau dengan kata lain $l(P_v)\leq (1+\epsilon)\cdot l(P)$ (\cite{Abraham2010}). Hitung skor $f(v)=2l(v)+\sigma(v)-pl(v)$. Dimana $l(v)$ adalah \textit{travel time } tentatif optimal dari $v$ ($fInfo[v]$)  saat menjalankan $TAMLBD$. $\sigma(v)$ adalah penjumlahan \textit{travel time} dari sisi-sisi yang muncul pada kedua rute \textit{Opt} dan rute $P_v$. $pl(v)$ adalah plateau dari simpul $v$. $spTree_{forward}$ dan $spTree_{backward}$ secara berturut-turut adalah \textit{shortest path tree} dari \textit{forward search} dan \textit{backward search} dari algoritma $TAMLBD$. Plateau $pl(v)$ dapat dicari dengan membuat subrute $P_{plateau\_v}\subseteq Opt$ yang berisi simpul-simpul $u\in P_{plateau\_v}$ (dengan $u \in spTree_{forward} \text{ dan } u \in spTree_{backward}$) dan $pl(v)$ dihitung dengan menjumlahkan bobot \textit{time travel} dari sisi-sisi yang menghubungkan himpunan simpul $P_{plateau\_v}$. Untuk memastikan kandidat rute alternatif memenuhi kriteria \textit{admissible paths}, kita membuang kandidat yang memiliki: $l(v)\geq (1+\epsilon)\cdot l(Opt), \sigma(v)\geq\gamma \cdot l(Opt), \text{ atau } pl(v)\leq \alpha \cdot l(Opt)$. Rute-rute alternatif yang dikembalikan adalah kandidat-kandidat yang memiliki $f(v)$ terkecil. Algoritma pencarian rute alternatif \textit{admissible paths} ditunjukkan pada Algoritma~\ref{alg:alternative-routes}. Algoritma ini memiliki kompleksitas waktu $O(C_v\cdot (E_1+U_1\log U_1+B^{2}+B \log B))$, dimana $C_v$ adalah jumlah \textit{via node} $v$ yang ditemukan oleh algoritma $TAMLBD$. Penelitian oleh \cite{Luxen2012} mempercepat kueri pencarian rute alternatif dengan cara melakukan prapemrosesan dan memanfaatkan struktur partisi graf \textit{multilevel} yang dijelaskan pada subbab~\ref{subsec:tdcrp-multilevel-partition}. Fase prapemrosesan menyimpan kandidat-kandidat \textit{via node} dengan cara melakukan kueri $findAlternativeRoutes$~\ref{alg:alternative-routes} pada setiap pasang \textit{boundary nodes} yang terletak pada sel yang berbeda dan tidak saling bertetangga. Untuk setiap pasang \textit{boundary nodes} pada sel-sel level 1 yang tidak saling bertetangga yang terletak pada sel yang sama pada $level>1$ atau terletak pada sel-sel bertetangga pada $level>1$  , jalankan Algoritma~\ref{alg:alternative-routes} dan simpan \textit{via nodes} dari rute-rute alternatif yang memenuhi kriteria \textit{Admissible Paths}. Prosedur pencarian \textit{via nodes} yang dilakukan secara rekursif pada $level>1$ dengan prosedur yang sama. $Vias_{i}$ adalah himpunan \textit{via nodes} yang disimpan dalam fase prapemrosesan untuk level-$i$. Kueri diawali dengan menentukan sel pada level 1 yang ditempati simpul asal $s$ dan simpul tujuan $t$, yaitu $c_1(s)$ dan $c_1(t)$. Jika $c_1(s)=c_1(t)$, jalankan Algoritma~\ref{alg:alternative-routes} untuk menemukan rute alternatif. Jika $c_1(s)\neq c_1(t)$, Cari level tertinggi $i$ dimana pada level $i$ simpul $s$ dan $t$ terletak pada sel yang sama atau bertetangga namun terletak pada sel berbeda dan tidak bertetangga pada level $i-1$, lalu \textit{filter} kandidat-kandidat \textit{via node} $v\in Vias_{i-1}$ yang memenuhi \textit{Admissible Paths} dan kembalikan hasilnya sebagai rute-rute alternatif. Jika $c_1(s)\neq c_1(t)$, $c_L(s) \neq C_L(t) $, dan $c_L(s) $ tidak bertetangga dengan $c_L(t)$, \textit{filter} kandidat-kandidat \textit{via node} $v\in Vias_{L}$ yang memenuhi \textit{Admissible Paths} dan kembalikan hasilnya sebagai rute-rute alternatif.


\begin{algorithm}
\caption{findAlternativeRoutes mengembalikan sejumlah $k$ rute alternatif terbaik} 
\label{alg:alternative-routes}
\resizebox{\textwidth}{!}{%
\begin{minipage}{\textwidth}
\scriptsize
\begin{algorithmic}[1]
\setstretch{0.9}
    \Procedure{findAlternativeRoutes}{$as,at: E, k: \mathbb{Z}^+$}: $Set$
        \State $(Via, l_{Opt}, \cdot, , fInfo, bInfo) =$\Call{TAMLBD}{$as,at$} 
        \State $potentialCandidates = \emptyset$
        \Procedure{calculatePlateau}{$v, l_v, fInfo, bInfo$}: $\mathbb{R}$
             \State $plateau = 0$
             \State $u = v$
             \While{$fInfo[u.entryId] \neq \perp$} \Comment{backtrack}
                    \If{$u\in bInfo  $} \Comment{$u \in spTree_{forward} \text{ dan } u \in spTree_{backward}$}
                        \State $cost_{uf}= fInfo[u.entryId].tt - fInfo[fInfo[u.entryId]].tt$
                        \State $ plateau = plateau + cost_{uf} $
                        \State $u = fInfo[u.entryId]$
                    \EndIf
             \EndWhile
             \State $u = v$
             \While{$bInfo[u.exitId] \neq \perp$} \Comment{backtrack}
                    \If{$u\in fInfo  $} \Comment{$u \in spTree_{forward} \text{ dan } u \in spTree_{backward}$}
                        \State $cost_{ub}= bInfo[u.exitId].tt - bInfo[bInfo[u.exitId]].tt$
                        \State $ plateau = plateau +  cost_{ub} $
                        \State $u = bInfo[u.exitId]$
                    \EndIf
             \EndWhile
             \State \textbf{return} $plateau$
        \EndProcedure
    
        \Procedure{calculatedistanceShare}{$Opt, P$}: $\mathbb{R}$
            \State $distanceShare= 0$
            \For{$p\in P$}
                \If {$p \in Opt$}
                    \State $distanceShare = distanceShare + p.weight$ 
                \EndIf 
            \EndFor
            \State \textbf{return} $distanceShare$
        \EndProcedure
        \For {$candidate \in Via$}
            \State $(\cdot, svTimeTravel, \cdot, fInfo_{sv}, bInfo_{sv}) = $\Call{TAMLBDCRP}{$s,candidate.entry $} 
            \State $(\cdot, vtTimeTravel, \cdot, fInfo_{vt}, bInfo_{vt}) = $\Call{TAMLBDCRP}{$candidate.exit, t $} 
            \State $l_v=svTimeTravel+vtTimeTravel$
            \If{$l_v \geq (1+\epsilon)\cdot l_{Opt} $}
                \State $\textbf{continue}$
            \EndIf

            
            \State $edgesSV=$\Call{backtrack}{$fInfo, candiate.node$}
            \State $edgesVT=$\Call{backtrack}{$bInfo, candiate.node$}
            \State $\sigma_v=$\Call{calculatedistanceShare}{$shortestPath, edgesSV \cup edgesVT$}
            \If{$\sigma_v\geq \gamma \cdot l_{Opt}$}
                \State \textbf{continue} 
            \EndIf
            \State $pl_v=$\Call{calculatePlateau}{$v, l_v, fInfo, bInfo$}
            \If{$pl_v \leq \alpha \cdot l_{Opt}$}
                \State \textbf{continue} 
            \EndIf
            \State $f_v=2l_v+\sigma_v-pl_v$
            \State $potentialCandidates  = potentialCandidates \cup \{candidate.node\}$
        \EndFor
        \State $sortedCandidates=$\Call{sort}{$potentialCandidates$}
        \State \textbf{return} $sortedCandidates[:k]$
    \EndProcedure

    
\end{algorithmic}
\end{minipage}%
}
\end{algorithm}



